{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Welcome to lemonjuce. This is my personal collection of notes and examples related to using JUCE. I created it as a way to keep track of useful information \u2013 things I often find myself needing but that are scattered across forums and other resources. It's meant to be a quick reference for me, arcathrax , so I don't have to hunt down the same solutions every time! One thing I\u2019ve found frustrating with the official JUCE tutorials is that they sometimes rely on custom classes defined in previous tutorials. It can be a bit of a surprise when you're trying to follow along and suddenly get errors because you haven't created those supporting classes yet! This documentation aims to provide more complete, self-contained examples whenever possible, or at least clearly indicate any dependencies on earlier tutorial content. The files are ordered in a way, that you, as a reader, should be able to make sence of it. However JUCE is a big framework and this documentation can not hold the information and implementation of any JUCE class.","title":"Home"},{"location":"#getting-started","text":"Welcome to lemonjuce. This is my personal collection of notes and examples related to using JUCE. I created it as a way to keep track of useful information \u2013 things I often find myself needing but that are scattered across forums and other resources. It's meant to be a quick reference for me, arcathrax , so I don't have to hunt down the same solutions every time! One thing I\u2019ve found frustrating with the official JUCE tutorials is that they sometimes rely on custom classes defined in previous tutorials. It can be a bit of a surprise when you're trying to follow along and suddenly get errors because you haven't created those supporting classes yet! This documentation aims to provide more complete, self-contained examples whenever possible, or at least clearly indicate any dependencies on earlier tutorial content. The files are ordered in a way, that you, as a reader, should be able to make sence of it. However JUCE is a big framework and this documentation can not hold the information and implementation of any JUCE class.","title":"Getting started"},{"location":"dsp/implementing_an_iir_filter/","text":"Implementing an IIR Filter What's an IIR Filter? An Infinite Impulse Response (IIR) filter is a type of digital or analog filter used in signal processing to modify signals by selectively attenuating or amplifying certain frequencies. Unlike finite impulse response (FIR) filters, which have a finite duration response to an impulse input, IIR filters theoretically continue their response indefinitely, hence the term \"infinite impulse response\". In JUCE it is generally used to create filters of various types, like a high-shelf filter, a low-cut filter and bandpass filter. Designing those filters can be very hard and sometimes even create an unstable output. Thankfully there is a JUCE helper class, that does this part for us. Implementation First off, you need to create the filter and add it to your ProcessorChain : file: PluginProcessor.h using ProcessorChain = juce::dsp::ProcessorChain < juce::dsp::IIR::Filter<float> >; Don't forget to update your enum, if you're using one. file: PluginProcessor.h enum { filterIndex }; Next create a function, that reads the parameters and adjusts the filter. This function should be called during the playback, so we can adjust the filters settings in real time. Lets call this function updateFilter() . Since we just want to change the settings and don't actually process any audio, we don't need any return type. Also we won't use this function outside of the PluginProcessor-class so we can create it in the private section: file: PluginProcessor.h private: void updateFilter(); In the next step, you need to define, what filter to use. In this tutorial you can currently choose from Peak Filter , Low-/Highshelf Filter and an Low-/Highcut Filter . Peak Filter Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have parameter's named Peak Freq , Peak Quality and Peak Gain or else this wont work. The quality parameter should be between 0.5 and 5, wile 0.5 creates a very gentle slope and 5 creates a very steap slope. Next, we will calculate the coefficients. Thankfully JUCE has a helper class, that can help us out. This is the juce::dsp::IIR::Coefficients<float> part. Here we also define, what type of filter we want. Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . file: PluginProcessor.cpp void AudioProcessor::updateFilter() { // storing the parameters auto peakFreq = apvts.getRawParameterValue(\"Peak Freq\")->load(); auto peakQuality = apvts.getRawParameterValue(\"Peak Quality\")->load(); auto peakGain = apvts.getRawParameterValue(\"Peak Gain\")->load(); // calculating the coefficients auto coefficients = juce::dsp::IIR::Coefficients<float>::makePeakFilter( peakFreq, peakQuality, juce::Decibels::decibelsToGain(peakGain) ); // updating the coefficients *leftChain.get<filterIndex>().coefficients = *coefficients; *rightChain.get<filterIndex>().coefficients = *coefficients; } High-/Lowcut Filter Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have a parameter named Cut Freq or else this wont work. This is the juce::dsp::FilterDesign<float> part. The number 1 will define, what order, that we are going to use. 1 creates an -6db/octave slope, 2 a -18db/octave slope and so on. Here we also define, what type of filter we want. Please note, that we will calculate both low- and highcut filters in this tutorial, since they are almost the same. Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . Also this will generate a lowcut filter, however you can change this, by just changing *lowCutCoefficients to *highCutCoefficients . file: PluginProcessor.cpp void AudioProcessor::updateFilter() { // storing the parameter auto cutFreq = apvts.getRawParameterValue(\"Cut Freq\")->load(); // calculating the coefficients auto lowCutCoefficients = juce::dsp::FilterDesign<float>::designIIRHighpassHighOrderButterworthMethod( cutFreq, getSampleRate(), 1 ) auto highCutCoefficients = juce::dsp::FilterDesign<float>::designIIRLowpassHighOrderButterworthMethod( cutFreq, getSampleRate(), 1 ) // updating the coefficients *leftChain.get<filterIndex>().coefficients = *lowCutCoefficients; *rightChain.get<filterIndex>().coefficients = *lowCutCoefficients; } High-/Lowshelf Filter Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have parameter's named Shelf Freq , Shelf Quality and Shelf Gain or else this wont work. The quality parameter should be between 0.5 and 5, wile 0.5 creates a very gentle slope and 5 creates a very steap slope. Next, we will calculate the coefficients. Thankfully JUCE has a helper class, that can help us out. This is the juce::dsp::IIR::Coefficients<float> part. Here we also define, what type of filter we want. We will create both coefficients for a highshelf filter and a lowshelf filter. You should be able to simply swap between them by changing *lowShelfCoefficients with *highShelfCoefficients . Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . void AudioProcessor::updateFilter() { // storing the parameters auto shelfFreq = apvts.getRawParameterValue(\"Shelf Freq\")->load(); auto shelfQuality = apvts.getRawParameterValue(\"Shelf Quality\")->load(); auto shelfGain = apvts.getRawParameterValue(\"Shelf Gain\")->load(); // calculating the coefficients auto lowShelfCoefficients = juce::dsp::IIR::Coefficients<float>::makeLowShelf( getSamplerate(), shelfFreq, shelfQuality, shelfGain ); auto highShelfCoefficients = juce::dsp::IIR::Coefficients<float>::makeHighShelf( getSampleRate(), shelfFreq, shelfQuality, shelfGain ); // updating the coefficients *leftChain.get<airFilterIndex>().coefficients = *lowShelfCoefficients; *rightChain.get<airFilterIndex>().coefficients = *lowShelfCoefficients; } Update the Filter Now we just need call this function every time, audio is being processed or prepared. This is done in the prepareToPlay and in the processBlock . We also should update the filters after we loaded the plugin's state. file: PluginProcessor.cpp void AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock) { // existing code updateFilter(); } void AudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages) { // existing code updateFilter(); } void SimpleEQAudioProcessor::setStateInformation (const void* data, int sizeInBytes) { auto tree = juce::ValueTree::readFromData(data, sizeInBytes); if (tree.isValid()) { apvts.replaceState(tree); updateFilters(); } } Now your filter should work and usable.","title":"Implementing an IIR Filter"},{"location":"dsp/implementing_an_iir_filter/#implementing-an-iir-filter","text":"","title":"Implementing an IIR Filter"},{"location":"dsp/implementing_an_iir_filter/#whats-an-iir-filter","text":"An Infinite Impulse Response (IIR) filter is a type of digital or analog filter used in signal processing to modify signals by selectively attenuating or amplifying certain frequencies. Unlike finite impulse response (FIR) filters, which have a finite duration response to an impulse input, IIR filters theoretically continue their response indefinitely, hence the term \"infinite impulse response\". In JUCE it is generally used to create filters of various types, like a high-shelf filter, a low-cut filter and bandpass filter. Designing those filters can be very hard and sometimes even create an unstable output. Thankfully there is a JUCE helper class, that does this part for us.","title":"What's an IIR Filter?"},{"location":"dsp/implementing_an_iir_filter/#implementation","text":"First off, you need to create the filter and add it to your ProcessorChain : file: PluginProcessor.h using ProcessorChain = juce::dsp::ProcessorChain < juce::dsp::IIR::Filter<float> >; Don't forget to update your enum, if you're using one. file: PluginProcessor.h enum { filterIndex }; Next create a function, that reads the parameters and adjusts the filter. This function should be called during the playback, so we can adjust the filters settings in real time. Lets call this function updateFilter() . Since we just want to change the settings and don't actually process any audio, we don't need any return type. Also we won't use this function outside of the PluginProcessor-class so we can create it in the private section: file: PluginProcessor.h private: void updateFilter(); In the next step, you need to define, what filter to use. In this tutorial you can currently choose from Peak Filter , Low-/Highshelf Filter and an Low-/Highcut Filter .","title":"Implementation"},{"location":"dsp/implementing_an_iir_filter/#peak-filter","text":"Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have parameter's named Peak Freq , Peak Quality and Peak Gain or else this wont work. The quality parameter should be between 0.5 and 5, wile 0.5 creates a very gentle slope and 5 creates a very steap slope. Next, we will calculate the coefficients. Thankfully JUCE has a helper class, that can help us out. This is the juce::dsp::IIR::Coefficients<float> part. Here we also define, what type of filter we want. Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . file: PluginProcessor.cpp void AudioProcessor::updateFilter() { // storing the parameters auto peakFreq = apvts.getRawParameterValue(\"Peak Freq\")->load(); auto peakQuality = apvts.getRawParameterValue(\"Peak Quality\")->load(); auto peakGain = apvts.getRawParameterValue(\"Peak Gain\")->load(); // calculating the coefficients auto coefficients = juce::dsp::IIR::Coefficients<float>::makePeakFilter( peakFreq, peakQuality, juce::Decibels::decibelsToGain(peakGain) ); // updating the coefficients *leftChain.get<filterIndex>().coefficients = *coefficients; *rightChain.get<filterIndex>().coefficients = *coefficients; }","title":"Peak Filter"},{"location":"dsp/implementing_an_iir_filter/#high-lowcut-filter","text":"Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have a parameter named Cut Freq or else this wont work. This is the juce::dsp::FilterDesign<float> part. The number 1 will define, what order, that we are going to use. 1 creates an -6db/octave slope, 2 a -18db/octave slope and so on. Here we also define, what type of filter we want. Please note, that we will calculate both low- and highcut filters in this tutorial, since they are almost the same. Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . Also this will generate a lowcut filter, however you can change this, by just changing *lowCutCoefficients to *highCutCoefficients . file: PluginProcessor.cpp void AudioProcessor::updateFilter() { // storing the parameter auto cutFreq = apvts.getRawParameterValue(\"Cut Freq\")->load(); // calculating the coefficients auto lowCutCoefficients = juce::dsp::FilterDesign<float>::designIIRHighpassHighOrderButterworthMethod( cutFreq, getSampleRate(), 1 ) auto highCutCoefficients = juce::dsp::FilterDesign<float>::designIIRLowpassHighOrderButterworthMethod( cutFreq, getSampleRate(), 1 ) // updating the coefficients *leftChain.get<filterIndex>().coefficients = *lowCutCoefficients; *rightChain.get<filterIndex>().coefficients = *lowCutCoefficients; }","title":"High-/Lowcut Filter"},{"location":"dsp/implementing_an_iir_filter/#high-lowshelf-filter","text":"Now lets define the function. We first start of by reading any parameters from our APVTS and storing them in a temporary variable, so we can read them better. Please note, that you need to have parameter's named Shelf Freq , Shelf Quality and Shelf Gain or else this wont work. The quality parameter should be between 0.5 and 5, wile 0.5 creates a very gentle slope and 5 creates a very steap slope. Next, we will calculate the coefficients. Thankfully JUCE has a helper class, that can help us out. This is the juce::dsp::IIR::Coefficients<float> part. Here we also define, what type of filter we want. We will create both coefficients for a highshelf filter and a lowshelf filter. You should be able to simply swap between them by changing *lowShelfCoefficients with *highShelfCoefficients . Lastly, we will replace the old coefficients with the new ones. Here we assume, that you have a stereo audio plugin with a leftChain and a rightChain . void AudioProcessor::updateFilter() { // storing the parameters auto shelfFreq = apvts.getRawParameterValue(\"Shelf Freq\")->load(); auto shelfQuality = apvts.getRawParameterValue(\"Shelf Quality\")->load(); auto shelfGain = apvts.getRawParameterValue(\"Shelf Gain\")->load(); // calculating the coefficients auto lowShelfCoefficients = juce::dsp::IIR::Coefficients<float>::makeLowShelf( getSamplerate(), shelfFreq, shelfQuality, shelfGain ); auto highShelfCoefficients = juce::dsp::IIR::Coefficients<float>::makeHighShelf( getSampleRate(), shelfFreq, shelfQuality, shelfGain ); // updating the coefficients *leftChain.get<airFilterIndex>().coefficients = *lowShelfCoefficients; *rightChain.get<airFilterIndex>().coefficients = *lowShelfCoefficients; }","title":"High-/Lowshelf Filter"},{"location":"dsp/implementing_an_iir_filter/#update-the-filter","text":"Now we just need call this function every time, audio is being processed or prepared. This is done in the prepareToPlay and in the processBlock . We also should update the filters after we loaded the plugin's state. file: PluginProcessor.cpp void AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock) { // existing code updateFilter(); } void AudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages) { // existing code updateFilter(); } void SimpleEQAudioProcessor::setStateInformation (const void* data, int sizeInBytes) { auto tree = juce::ValueTree::readFromData(data, sizeInBytes); if (tree.isValid()) { apvts.replaceState(tree); updateFilters(); } } Now your filter should work and usable.","title":"Update the Filter"},{"location":"getting_started/creating_an_audio_plugin/","text":"Creating an audio plugin Create the project To create an audio plug-in with JUCE, open \"Projucer\" and select \"Plug-In>Basic\". See Creating an Application if you don't know how to do that. In this tutorial we're going to name this plugin SimpleAudioPlugin . In this tutorial, we are going to create a VST3 plug-in, so make sure, that the VST3 setting is ticked in the Plugin Formats field in the project configuration settings: Project configuration In the project configuration you can change and tweak much more settings. Here you can change for example the project version, the plug-in type (generator or effect), change the plug-in category (ex. distortion or delay) and much more. However we dont need to change anything besides the \"plugin format\". Next click the \" Save and Open in IDE \"-button and build it . Setup debugging environment (optional) When creating a audio plugin, accessing it fast and reliable is sometimes a hassle since DAW's sometimes have issues finding updated plugins and are very cpu intensive. Thankfully, JUCE has a simple environment to debug your application called \"AudioPluginHost\". This application serves as a host for your plug-ing and you can use it just like in a DAW. The \"AudioPluginHost\" can be started very quickly and is very easy to use, which makes it perfect for debugging. To use the \"AudioPluginHost\", you first need to build it, since it doesn't come pre-compiled, like \"Projucer\" does. Go to JUCE/extras/AudioPluginHost and open the .jucer file. Click the \"Save and Open in IDE\"-button and build the project. This will create a binary file, located in one of the following folders: OS Location macOS JUCE/extras/AudioPluginHost/Builds/MacOSX/build/... Windows JUCE\\extras\\AudioPluginHost\\Builds\\VisualStudio2022\\... Note: The application is somewhere in the subfolders of the build folder. You can can change the location of the \"AudioPluginHost\" to your likings. If you run the \"AudioPluginHost\", you should see the graphical node editor that looks like this: You can search for plugins by going to Options>Edit the List of Available Plug-ins... . Click Options...>Scan for new or updated VST3 plug-ins to see the folders, that should be scanned by the \"AudioPluginHost\". Here you can select the folders, that are going to be scanned for new VST3 plug-ins. Here you can add or remove custom directories: Once the scan is complete go back to the node editor and right click, then select your plug-in from the context menu (it will be under a company called \"yourcompany\" by default. You can edit this in the \"Projucer\"). Connect the nodes up such that the Audio is routed to and from the \"SimpleAudioPlugin\": If you now double click onto the plugin node, you open the GUI of the plugin. The default does nothing but show Hello world . Automatically run AudioPluginHost If you want to run \"AudioPluginHost\" automatically when building your project, you can do that via the IDE. In Xcode click Product>Scheme>Edit Scheme... , then under Run>Info>Executable>Other... search and select the \"AudioPluginHost\". In Visual Studio go to SimpleAudioPlugin_VST3 Debug Properties>Debugging>Command and change it to the path to the \"AudioPluginHost\".","title":"Creating an audio plugin"},{"location":"getting_started/creating_an_audio_plugin/#creating-an-audio-plugin","text":"","title":"Creating an audio plugin"},{"location":"getting_started/creating_an_audio_plugin/#create-the-project","text":"To create an audio plug-in with JUCE, open \"Projucer\" and select \"Plug-In>Basic\". See Creating an Application if you don't know how to do that. In this tutorial we're going to name this plugin SimpleAudioPlugin . In this tutorial, we are going to create a VST3 plug-in, so make sure, that the VST3 setting is ticked in the Plugin Formats field in the project configuration settings: Project configuration In the project configuration you can change and tweak much more settings. Here you can change for example the project version, the plug-in type (generator or effect), change the plug-in category (ex. distortion or delay) and much more. However we dont need to change anything besides the \"plugin format\". Next click the \" Save and Open in IDE \"-button and build it .","title":"Create the project"},{"location":"getting_started/creating_an_audio_plugin/#setup-debugging-environment-optional","text":"When creating a audio plugin, accessing it fast and reliable is sometimes a hassle since DAW's sometimes have issues finding updated plugins and are very cpu intensive. Thankfully, JUCE has a simple environment to debug your application called \"AudioPluginHost\". This application serves as a host for your plug-ing and you can use it just like in a DAW. The \"AudioPluginHost\" can be started very quickly and is very easy to use, which makes it perfect for debugging. To use the \"AudioPluginHost\", you first need to build it, since it doesn't come pre-compiled, like \"Projucer\" does. Go to JUCE/extras/AudioPluginHost and open the .jucer file. Click the \"Save and Open in IDE\"-button and build the project. This will create a binary file, located in one of the following folders: OS Location macOS JUCE/extras/AudioPluginHost/Builds/MacOSX/build/... Windows JUCE\\extras\\AudioPluginHost\\Builds\\VisualStudio2022\\... Note: The application is somewhere in the subfolders of the build folder. You can can change the location of the \"AudioPluginHost\" to your likings. If you run the \"AudioPluginHost\", you should see the graphical node editor that looks like this: You can search for plugins by going to Options>Edit the List of Available Plug-ins... . Click Options...>Scan for new or updated VST3 plug-ins to see the folders, that should be scanned by the \"AudioPluginHost\". Here you can select the folders, that are going to be scanned for new VST3 plug-ins. Here you can add or remove custom directories: Once the scan is complete go back to the node editor and right click, then select your plug-in from the context menu (it will be under a company called \"yourcompany\" by default. You can edit this in the \"Projucer\"). Connect the nodes up such that the Audio is routed to and from the \"SimpleAudioPlugin\": If you now double click onto the plugin node, you open the GUI of the plugin. The default does nothing but show Hello world .","title":"Setup debugging environment (optional)"},{"location":"getting_started/creating_an_audio_plugin/#automatically-run-audiopluginhost","text":"If you want to run \"AudioPluginHost\" automatically when building your project, you can do that via the IDE. In Xcode click Product>Scheme>Edit Scheme... , then under Run>Info>Executable>Other... search and select the \"AudioPluginHost\". In Visual Studio go to SimpleAudioPlugin_VST3 Debug Properties>Debugging>Command and change it to the path to the \"AudioPluginHost\".","title":"Automatically run AudioPluginHost"},{"location":"getting_started/installation/","text":"Installation Installing JUCE Before creating your first JUCE application, make sure that your local machine has either Visual Studio or Xcode installed. In addition, you need to install the C++ toolchain for the according opperating system: Visual Studio : During installation, ensure that you select the \"Desktop development with C++\" workload. Xcode : After installation, ensure that you the right components: File>Settings>Components>macOS XX.X You now may download JUCE from here . Unpack the JUCE folder and place it to some location on your computer. Your user home folder is a convenient place. Go into the JUCE folder you just moved. Launch the \"Projucer\", which is located in there. Next, you should set the global paths for \"Projucer\". You can do this via the menu bar on the top left: Creating an Application If you are launching \"Projucer\" for the first time, you are presented with the new project window. You also can access this window via File>New Project . Projucer - New Project Window Select your project type On the left-hand side of \"Projucer\", you can select a project type. This will add all the dependencies to create the programm selected and create code, to make the application run. You can select from the following types: Project type Description Application > Blank Creates a blank JUCE application Application > GUI Creates a blank JUCE application with a application window. Application > Audio Creates a application like \"Application > GUI\", but with all the setup code for audio in- and outputs. Application > Console Creates a command-line application without a GUI Application > Animated Creates a JUCE GUI application which is optimized for animations. Application > OpenGL Creates a JUCE GUI application with support for openGL drawing, like 3D model import and GLSL shaders. Plug-In > Basic Creates a basic audio plug-in. This plugin can be exported in the VST, Audio Unit and AAX formats. Plug-In > ARA Creates a plugin with ARA (Audio Random Access) support. Library > Static Library Creates a library that will be compiled into the final executable. Library > Dynamic Library Creates a library that are linked at runtime. Alternatively, you may start with a example project. You can open those by clicking the \"Open Example\" tab on the left-hand side of \"Projucer\". Create the Project After you selected the project type, you can fill out some additional project settings on the right-hand side: - Project Name : Give your application a custom Name - Modules : Here you can add and remove modules, that you are going to use in your project. - Exporters : Here you select which IDEs you want to use to build and debug your app. The Projucer currently has exporters for the following IDEs: OS build systems macOS Xcode Windows Visual Studio Linux Makefile iOS Xcode Android Android Studio Note: If you use Visual Studio create a audio plugin and don't want to manually copy the plugin after every build, I suggest you to enable the \"Plugin Copy Step\": Export the project and open in IDE After you created your project and set everything up, you can launch your IDE withing Projucer: Open existing projects To open existing Projucer project's, you can either double-click the .jucer file in your project or click on \"File>Open...\" in Projucer.","title":"Installation"},{"location":"getting_started/installation/#installation","text":"","title":"Installation"},{"location":"getting_started/installation/#installing-juce","text":"Before creating your first JUCE application, make sure that your local machine has either Visual Studio or Xcode installed. In addition, you need to install the C++ toolchain for the according opperating system: Visual Studio : During installation, ensure that you select the \"Desktop development with C++\" workload. Xcode : After installation, ensure that you the right components: File>Settings>Components>macOS XX.X You now may download JUCE from here . Unpack the JUCE folder and place it to some location on your computer. Your user home folder is a convenient place. Go into the JUCE folder you just moved. Launch the \"Projucer\", which is located in there. Next, you should set the global paths for \"Projucer\". You can do this via the menu bar on the top left:","title":"Installing JUCE"},{"location":"getting_started/installation/#creating-an-application","text":"If you are launching \"Projucer\" for the first time, you are presented with the new project window. You also can access this window via File>New Project . Projucer - New Project Window","title":"Creating an Application"},{"location":"getting_started/installation/#select-your-project-type","text":"On the left-hand side of \"Projucer\", you can select a project type. This will add all the dependencies to create the programm selected and create code, to make the application run. You can select from the following types: Project type Description Application > Blank Creates a blank JUCE application Application > GUI Creates a blank JUCE application with a application window. Application > Audio Creates a application like \"Application > GUI\", but with all the setup code for audio in- and outputs. Application > Console Creates a command-line application without a GUI Application > Animated Creates a JUCE GUI application which is optimized for animations. Application > OpenGL Creates a JUCE GUI application with support for openGL drawing, like 3D model import and GLSL shaders. Plug-In > Basic Creates a basic audio plug-in. This plugin can be exported in the VST, Audio Unit and AAX formats. Plug-In > ARA Creates a plugin with ARA (Audio Random Access) support. Library > Static Library Creates a library that will be compiled into the final executable. Library > Dynamic Library Creates a library that are linked at runtime. Alternatively, you may start with a example project. You can open those by clicking the \"Open Example\" tab on the left-hand side of \"Projucer\".","title":"Select your project type"},{"location":"getting_started/installation/#create-the-project","text":"After you selected the project type, you can fill out some additional project settings on the right-hand side: - Project Name : Give your application a custom Name - Modules : Here you can add and remove modules, that you are going to use in your project. - Exporters : Here you select which IDEs you want to use to build and debug your app. The Projucer currently has exporters for the following IDEs: OS build systems macOS Xcode Windows Visual Studio Linux Makefile iOS Xcode Android Android Studio Note: If you use Visual Studio create a audio plugin and don't want to manually copy the plugin after every build, I suggest you to enable the \"Plugin Copy Step\":","title":"Create the Project"},{"location":"getting_started/installation/#export-the-project-and-open-in-ide","text":"After you created your project and set everything up, you can launch your IDE withing Projucer:","title":"Export the project and open in IDE"},{"location":"getting_started/installation/#open-existing-projects","text":"To open existing Projucer project's, you can either double-click the .jucer file in your project or click on \"File>Open...\" in Projucer.","title":"Open existing projects"},{"location":"getting_started/plugin_architecture/","text":"Plugin architecture An audio plug-in, made with JUCE consists of several folders and files. However, the main stuff will happen within two files: The PluginProcessor and the PluginEditor . The \"PluginProcessor\" will process the audio while the \"PluginEditor\" will handle the GUI. We will take a closer look later in this file. General structure Every audio plug-in, made with JUCE will have the following folders: YourAudioPlugin |-Source |-PluginEditor.cpp |-PluginEditor.h |-PluginProcessor.cpp |-PluginEditor.h |-Builds |-Juce Library Code The Source -folder holds the source code of the JUCE application. The GUI is defined here, aswell as the audio processing stuff. The Builds -folder holds the export targets generated by the \"Projucer\". The generated binaries will also be exported to some subfolder here. Lastly, the folder JuceLibraryCode holds autogenerated files, that are essential to include the JUCE modules. Those will be deleted and completely re-written whenever the Projucer saves your project. You really should't change anything here since it just will get deleted. Since most of the work is done in the Source -folder, we should take a closer look to the files inside. PluginProcessor In a JUCE audio plug-in, the PluginProcessor is the core engine that handles all audio processing, parameter management and plugin state. It is where your plugin actually does the sound-related work. You're going to write a lot of code in some functions and in some, you maybe don't need to write that much code. Here are the most used classes within \"PluginProcessor\": prepareToPlay() : Initialization happen here. This will get called right before the audio is being processed. processBlock() : Here you will manipulate the audio in real time. releaseRessources() : When playback stops, you can use this as an opportunity to free up any spare memory, etc. getStateInformation() : This will load the state of the plug-in. setStateInformation() : This will save the state of the plug-in. createEditor() : This will create the window for the plug-in. Note: The \"state\" of the plugin is just in what state the parameters of the plugin are. PluginEditor In a JUCE audio plug-in, the \"PluginEditor\" is the graphical user interface (GUI) that allows users to interact with your plugin. It displays sliders, buttons, meters, and other controls, and connects them to the audio processing happening in the \"PluginProcessor\". Here, you will build your interface and decide how users will interact with your parameters. Sometimes there are just few sliders, sometimes it's a whole custom visual environment. Here are the classes within \"PluginEditor\": paint() : This is where you draw any custom graphics or backgrounds. resized() : Called when the editor changes size.","title":"Plugin architecture"},{"location":"getting_started/plugin_architecture/#plugin-architecture","text":"An audio plug-in, made with JUCE consists of several folders and files. However, the main stuff will happen within two files: The PluginProcessor and the PluginEditor . The \"PluginProcessor\" will process the audio while the \"PluginEditor\" will handle the GUI. We will take a closer look later in this file.","title":"Plugin architecture"},{"location":"getting_started/plugin_architecture/#general-structure","text":"Every audio plug-in, made with JUCE will have the following folders: YourAudioPlugin |-Source |-PluginEditor.cpp |-PluginEditor.h |-PluginProcessor.cpp |-PluginEditor.h |-Builds |-Juce Library Code The Source -folder holds the source code of the JUCE application. The GUI is defined here, aswell as the audio processing stuff. The Builds -folder holds the export targets generated by the \"Projucer\". The generated binaries will also be exported to some subfolder here. Lastly, the folder JuceLibraryCode holds autogenerated files, that are essential to include the JUCE modules. Those will be deleted and completely re-written whenever the Projucer saves your project. You really should't change anything here since it just will get deleted. Since most of the work is done in the Source -folder, we should take a closer look to the files inside.","title":"General structure"},{"location":"getting_started/plugin_architecture/#pluginprocessor","text":"In a JUCE audio plug-in, the PluginProcessor is the core engine that handles all audio processing, parameter management and plugin state. It is where your plugin actually does the sound-related work. You're going to write a lot of code in some functions and in some, you maybe don't need to write that much code. Here are the most used classes within \"PluginProcessor\": prepareToPlay() : Initialization happen here. This will get called right before the audio is being processed. processBlock() : Here you will manipulate the audio in real time. releaseRessources() : When playback stops, you can use this as an opportunity to free up any spare memory, etc. getStateInformation() : This will load the state of the plug-in. setStateInformation() : This will save the state of the plug-in. createEditor() : This will create the window for the plug-in. Note: The \"state\" of the plugin is just in what state the parameters of the plugin are.","title":"PluginProcessor"},{"location":"getting_started/plugin_architecture/#plugineditor","text":"In a JUCE audio plug-in, the \"PluginEditor\" is the graphical user interface (GUI) that allows users to interact with your plugin. It displays sliders, buttons, meters, and other controls, and connects them to the audio processing happening in the \"PluginProcessor\". Here, you will build your interface and decide how users will interact with your parameters. Sometimes there are just few sliders, sometimes it's a whole custom visual environment. Here are the classes within \"PluginEditor\": paint() : This is where you draw any custom graphics or backgrounds. resized() : Called when the editor changes size.","title":"PluginEditor"},{"location":"getting_started/what_is_juce/","text":"What is JUCE? JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plug-ins libraries. It is dual licensed under the GPLv3 and a commercial license. The aim of JUCE is to allow software to be written such that the same source code will compile and run identically on Windows, macOS and Linux platforms. It supports various development environments and compilers. Features JUCE provides a range of functions, covering user-interface elements, graphics, audio, XML and JSON parsing, networking, cryptography, multi-threading, an integrated interpreter that mimics ECMAScript's syntax and various other commonly used features. A notable feature of JUCE when compared to other similar frameworks, like Qt or GTK, is its large set of audio functionality; this is because JUCE was originally developed as a framework for Tracktion, an audio sequencer, before being split off into a standalone product. JUCE comes with wrapper classes for building audio and browser plugins. When building an audio plugin, multiple plugin formats can be selected for build targets. Those include VST & VST3, RTAS, AAX and Audio Units. Tools Projucer The \"Projucer\" is an IDE tool for creating and managing JUCE projects. When the files and settings for a JUCE project have been specified, the Projucer automatically generates a collection of 3rd-party project files to allow the project to be compiled natively on each target platform. It can currently generate Xcode projects, Visual Studio Projects, Linux Makefiles, Android Ant builds and CodeBlocks projects. AudioPluginHost The \"AudioPluginHost\" is a standalone application included with JUCE that allows users to load, test, and route audio plugins in a flexible environment. Designed primarly for plugin development and testing, it supports both VST and AU plugin formats and provides a real-time visual interface for managing plugin chains. With its built-in graph editor, users can freely connect audio and MIDI paths between loaded plugins, making it an essential tool for quickly verifying plugin behaviour outside of a DAW.","title":"What is JUCE?"},{"location":"getting_started/what_is_juce/#what-is-juce","text":"JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plug-ins libraries. It is dual licensed under the GPLv3 and a commercial license. The aim of JUCE is to allow software to be written such that the same source code will compile and run identically on Windows, macOS and Linux platforms. It supports various development environments and compilers.","title":"What is JUCE?"},{"location":"getting_started/what_is_juce/#features","text":"JUCE provides a range of functions, covering user-interface elements, graphics, audio, XML and JSON parsing, networking, cryptography, multi-threading, an integrated interpreter that mimics ECMAScript's syntax and various other commonly used features. A notable feature of JUCE when compared to other similar frameworks, like Qt or GTK, is its large set of audio functionality; this is because JUCE was originally developed as a framework for Tracktion, an audio sequencer, before being split off into a standalone product. JUCE comes with wrapper classes for building audio and browser plugins. When building an audio plugin, multiple plugin formats can be selected for build targets. Those include VST & VST3, RTAS, AAX and Audio Units.","title":"Features"},{"location":"getting_started/what_is_juce/#tools","text":"","title":"Tools"},{"location":"getting_started/what_is_juce/#projucer","text":"The \"Projucer\" is an IDE tool for creating and managing JUCE projects. When the files and settings for a JUCE project have been specified, the Projucer automatically generates a collection of 3rd-party project files to allow the project to be compiled natively on each target platform. It can currently generate Xcode projects, Visual Studio Projects, Linux Makefiles, Android Ant builds and CodeBlocks projects.","title":"Projucer"},{"location":"getting_started/what_is_juce/#audiopluginhost","text":"The \"AudioPluginHost\" is a standalone application included with JUCE that allows users to load, test, and route audio plugins in a flexible environment. Designed primarly for plugin development and testing, it supports both VST and AU plugin formats and provides a real-time visual interface for managing plugin chains. With its built-in graph editor, users can freely connect audio and MIDI paths between loaded plugins, making it an essential tool for quickly verifying plugin behaviour outside of a DAW.","title":"AudioPluginHost"},{"location":"gui/creating_a_custom_lookandfeel/","text":"Creating a Custom Look and Feel What is a LookAndFeel? In Juce, the LookAndFeel class provides an abstraction layer for visual styling of your application's user interface elements. Think of it as a theme engine. It defines how components like buttons, sliders, text labels, and windows look \u2013 their colours, fonts, borders, shapes, and overall aesthetic. Without a LookAndFeel, Juce would default to a basic, often unappealing, visual style. By implementing or using pre-built LookAndFeel classes, you can easily customize the appearance of your application to match its brand, desired feel (modern, retro, minimalist, etc.), and platform conventions. Using a custom LookAndFeel allows for consistent styling across different platforms while still maintaining a unique identity. Implementation Creating the files First, the required files need to be created. This is done via the Projucer application. The Projucer will generate the necessary header and source code files for your custom LookAndFeel class. The Header File Since we don't want to create everything from scratch, we inherit from an existing JUCE LookAndFeel class. The recommended base class is juce::LookAndFeel_V4 , which represents the newest and most \"up-to-date\" LookAndFeel provided by the Juce framework. This provides a good foundation for customization while leveraging existing functionality. Make sure you include the JUCE header, as we need some JUCE classes. Next, we define the class. We will override specific functions from juce::LookAndFeel_V4 to customize its behavior. file : CustomLookAndFeel.h #pragma once #include <JuceHeader.h> class CustomLookAndFeel : public juce::LookAndFeel_V4 { public: CustomLookAndFeel(); void drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height, float sliderPos, float rotaryStartAngle, float rotaryEndAngle, Slider& slider) override; private: JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CustomLookAndFeel) }; Explanation: #pragma once : Ensures the header file is included only once during compilation. juce::Graphics& g : This is a reference to the graphics context used for drawing. Slider& slider : A reference to the Slider object being drawn. This allows you to access its properties and potentially modify its appearance directly within the draw function. JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CustomLookAndFeel) : Prevents copying of the LookAndFeel class, which is generally desirable for consistency and resource management. The leak detector helps identify potential memory issues if you accidentally try to copy it. The Source File Next, we implement the functions declared in the header file. Drawing custom UI elements requires careful calculation and drawing operations. file : CustomLookAndFeel.cpp #include \"CustomLookAndFeel.h\" CustomLookAndFeel::CustomLookAndFeel() { setColour(juce::ResizableWindow::backgroundColourId, juce::Colours::black); setColour(juce::Slider::backgroundColourId, juce::Colour(36, 5, 5)); setColour(juce::Slider::trackColourId, juce::Colour(0xFF820104)); } void CustomLookAndFeel::drawRotarySlider (juce::Graphics& g, int x, int y, int width, int height, float sliderPosProportional, float rotaryStartAngle, float rotaryEndAngle, juce::Slider& slider) { // slider properties slider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0); slider.setVelocityModeParameters(1.0, 1, 0.0, true, juce::ModifierKeys::shiftModifier); // calculate variables juce::Rectangle<float> bounds; bounds = juce::Rectangle<int>(x, y, width, height).toFloat(); auto radius = bounds.getWidth() / 2.0f; auto lineWidth = 3.0f; auto arcRadius = radius - lineWidth / 2.0f; float angle = rotaryStartAngle + sliderPosProportional * (rotaryEndAngle - rotaryStartAngle); float centerX = x + width * 0.5f; float centerY = y + height * 0.5f; // draw background circle g.setColour(slider.findColour(juce::Slider::backgroundColourId)); g.fillEllipse(bounds); // draw arc auto strokeType = juce::PathStrokeType( lineWidth, juce::PathStrokeType::curved, juce::PathStrokeType::rounded); juce::Path valueArc; valueArc.addCentredArc(centerX, centerY, arcRadius, arcRadius, 0.0f, rotaryStartAngle, angle, true); g.setColour(slider.findColour(juce::Slider::trackColourId)); g.strokePath(valueArc, strokeType); } Explanation: #include <JuceHeader.h> : Crucially important to include the JuceHeader header file so that you can access the classes and methods of the JUCE framework. setColour(juce::ResizableWindow::backgroundColourId, juce::Colours::black); : Sets the background colour of resizable windows (like your main application window) to black. juce::Colours::black is a convenient way to specify standard colours. setColour(juce::Slider::backgroundColourId, juce::Colour(36, 5, 5)); : Sets the background colour of sliders to a very dark red. The 36, 5, 5 represents the rgb values for the color. setColour(juce::Slider::trackColourId, juce::Colour(0xFF820104)); : Sets the track colour of sliders to a dark red. The 0xFF820104 represents the hexadecimal value for the color (with the alpha channel set to fully opaque). drawRotarySlider : This function is responsible for drawing the visual representation of a rotary slider. It calculates various parameters like radius, line width, and arc angle based on the provided dimensions and slider position. It then uses juce::Path to create an elliptical arc representing the slider's value and draws it using g.strokePath . The properties of the slider are also configured here. For example, we now have shift-functionality. Using Your Custom LookAndFeel To use your custom LookAndFeel in your application: Include necessary header : Include the header for your LookAndFeel class. Instantiation : Create an instance of your CustomLookAndFeel class. file : PluginEditor.h or MainComponent.h #pragma once #include <JuceHeader.h> #include \"CustomLookAndFeel.h\" class MainComponent : public juce::Component { public: MainComponent(); ~MainComponent() override; void paint (juce::Graphics&) override; void resized() override; private: CustomLookAndFeel customLookAndFeel; juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; Setting the LookAndFeel : Use setLookAndFeel() on your main component or window and a slider. Delete references in destructor : In the destructor use setLookAndFeel(nullptr) to avoid bugs. file : PluginEditor.cpp or MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { setSize (600, 600); addAndMakeVisible(slider); setLookAndFeel(&customLookAndFeel); slider.setLookAndFeel(&customLookAndFeel); slider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag); } MainComponent::~MainComponent() { setLookAndFeel(nullptr); slider.setLookAndFeel(nullptr); } void MainComponent::paint (juce::Graphics& g) { g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId)); } void MainComponent::resized() { slider.setBounds(getBounds()); } Further Customization & Considerations Other Components: You can override other drawing functions in LookAndFeel_V4 to customize the appearance of other UI components like buttons, text labels, and knobs. Refer to the Juce documentation for a complete list of available overrides. Color Management : Consider using juce::Colour objects for all color definitions. This allows for easier manipulation and consistency across your application.","title":"Creating a custom LookAndFeel"},{"location":"gui/creating_a_custom_lookandfeel/#creating-a-custom-look-and-feel","text":"","title":"Creating a Custom Look and Feel"},{"location":"gui/creating_a_custom_lookandfeel/#what-is-a-lookandfeel","text":"In Juce, the LookAndFeel class provides an abstraction layer for visual styling of your application's user interface elements. Think of it as a theme engine. It defines how components like buttons, sliders, text labels, and windows look \u2013 their colours, fonts, borders, shapes, and overall aesthetic. Without a LookAndFeel, Juce would default to a basic, often unappealing, visual style. By implementing or using pre-built LookAndFeel classes, you can easily customize the appearance of your application to match its brand, desired feel (modern, retro, minimalist, etc.), and platform conventions. Using a custom LookAndFeel allows for consistent styling across different platforms while still maintaining a unique identity.","title":"What is a LookAndFeel?"},{"location":"gui/creating_a_custom_lookandfeel/#implementation","text":"","title":"Implementation"},{"location":"gui/creating_a_custom_lookandfeel/#creating-the-files","text":"First, the required files need to be created. This is done via the Projucer application. The Projucer will generate the necessary header and source code files for your custom LookAndFeel class.","title":"Creating the files"},{"location":"gui/creating_a_custom_lookandfeel/#the-header-file","text":"Since we don't want to create everything from scratch, we inherit from an existing JUCE LookAndFeel class. The recommended base class is juce::LookAndFeel_V4 , which represents the newest and most \"up-to-date\" LookAndFeel provided by the Juce framework. This provides a good foundation for customization while leveraging existing functionality. Make sure you include the JUCE header, as we need some JUCE classes. Next, we define the class. We will override specific functions from juce::LookAndFeel_V4 to customize its behavior. file : CustomLookAndFeel.h #pragma once #include <JuceHeader.h> class CustomLookAndFeel : public juce::LookAndFeel_V4 { public: CustomLookAndFeel(); void drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height, float sliderPos, float rotaryStartAngle, float rotaryEndAngle, Slider& slider) override; private: JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CustomLookAndFeel) }; Explanation: #pragma once : Ensures the header file is included only once during compilation. juce::Graphics& g : This is a reference to the graphics context used for drawing. Slider& slider : A reference to the Slider object being drawn. This allows you to access its properties and potentially modify its appearance directly within the draw function. JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CustomLookAndFeel) : Prevents copying of the LookAndFeel class, which is generally desirable for consistency and resource management. The leak detector helps identify potential memory issues if you accidentally try to copy it.","title":"The Header File"},{"location":"gui/creating_a_custom_lookandfeel/#the-source-file","text":"Next, we implement the functions declared in the header file. Drawing custom UI elements requires careful calculation and drawing operations. file : CustomLookAndFeel.cpp #include \"CustomLookAndFeel.h\" CustomLookAndFeel::CustomLookAndFeel() { setColour(juce::ResizableWindow::backgroundColourId, juce::Colours::black); setColour(juce::Slider::backgroundColourId, juce::Colour(36, 5, 5)); setColour(juce::Slider::trackColourId, juce::Colour(0xFF820104)); } void CustomLookAndFeel::drawRotarySlider (juce::Graphics& g, int x, int y, int width, int height, float sliderPosProportional, float rotaryStartAngle, float rotaryEndAngle, juce::Slider& slider) { // slider properties slider.setTextBoxStyle(juce::Slider::NoTextBox, false, 0, 0); slider.setVelocityModeParameters(1.0, 1, 0.0, true, juce::ModifierKeys::shiftModifier); // calculate variables juce::Rectangle<float> bounds; bounds = juce::Rectangle<int>(x, y, width, height).toFloat(); auto radius = bounds.getWidth() / 2.0f; auto lineWidth = 3.0f; auto arcRadius = radius - lineWidth / 2.0f; float angle = rotaryStartAngle + sliderPosProportional * (rotaryEndAngle - rotaryStartAngle); float centerX = x + width * 0.5f; float centerY = y + height * 0.5f; // draw background circle g.setColour(slider.findColour(juce::Slider::backgroundColourId)); g.fillEllipse(bounds); // draw arc auto strokeType = juce::PathStrokeType( lineWidth, juce::PathStrokeType::curved, juce::PathStrokeType::rounded); juce::Path valueArc; valueArc.addCentredArc(centerX, centerY, arcRadius, arcRadius, 0.0f, rotaryStartAngle, angle, true); g.setColour(slider.findColour(juce::Slider::trackColourId)); g.strokePath(valueArc, strokeType); } Explanation: #include <JuceHeader.h> : Crucially important to include the JuceHeader header file so that you can access the classes and methods of the JUCE framework. setColour(juce::ResizableWindow::backgroundColourId, juce::Colours::black); : Sets the background colour of resizable windows (like your main application window) to black. juce::Colours::black is a convenient way to specify standard colours. setColour(juce::Slider::backgroundColourId, juce::Colour(36, 5, 5)); : Sets the background colour of sliders to a very dark red. The 36, 5, 5 represents the rgb values for the color. setColour(juce::Slider::trackColourId, juce::Colour(0xFF820104)); : Sets the track colour of sliders to a dark red. The 0xFF820104 represents the hexadecimal value for the color (with the alpha channel set to fully opaque). drawRotarySlider : This function is responsible for drawing the visual representation of a rotary slider. It calculates various parameters like radius, line width, and arc angle based on the provided dimensions and slider position. It then uses juce::Path to create an elliptical arc representing the slider's value and draws it using g.strokePath . The properties of the slider are also configured here. For example, we now have shift-functionality.","title":"The Source File"},{"location":"gui/creating_a_custom_lookandfeel/#using-your-custom-lookandfeel","text":"To use your custom LookAndFeel in your application: Include necessary header : Include the header for your LookAndFeel class. Instantiation : Create an instance of your CustomLookAndFeel class. file : PluginEditor.h or MainComponent.h #pragma once #include <JuceHeader.h> #include \"CustomLookAndFeel.h\" class MainComponent : public juce::Component { public: MainComponent(); ~MainComponent() override; void paint (juce::Graphics&) override; void resized() override; private: CustomLookAndFeel customLookAndFeel; juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MainComponent) }; Setting the LookAndFeel : Use setLookAndFeel() on your main component or window and a slider. Delete references in destructor : In the destructor use setLookAndFeel(nullptr) to avoid bugs. file : PluginEditor.cpp or MainComponent.cpp #include \"MainComponent.h\" MainComponent::MainComponent() { setSize (600, 600); addAndMakeVisible(slider); setLookAndFeel(&customLookAndFeel); slider.setLookAndFeel(&customLookAndFeel); slider.setSliderStyle(juce::Slider::RotaryHorizontalVerticalDrag); } MainComponent::~MainComponent() { setLookAndFeel(nullptr); slider.setLookAndFeel(nullptr); } void MainComponent::paint (juce::Graphics& g) { g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId)); } void MainComponent::resized() { slider.setBounds(getBounds()); }","title":"Using Your Custom LookAndFeel"},{"location":"gui/creating_a_custom_lookandfeel/#further-customization-considerations","text":"Other Components: You can override other drawing functions in LookAndFeel_V4 to customize the appearance of other UI components like buttons, text labels, and knobs. Refer to the Juce documentation for a complete list of available overrides. Color Management : Consider using juce::Colour objects for all color definitions. This allows for easier manipulation and consistency across your application.","title":"Further Customization &amp; Considerations"},{"location":"information/contributing/","text":"Contributing Welcome! Our goal is to provide clear, practical, and a self-contained documentation for JUCE development. Your contributions are vital to making that happen. Why Contribute? lemonjuce aims to bridge the gap between the powerful capabilities of JUCE and the sometimes-opaque nature of its documentation. By contributing, you'll: Improve your own understanding : Explaining concepts helps solidify them in your mind. Help others : Share your knowledge and make JUCE development more accessible to everyone. Shape lemonjuce : Help us define the scope and quality of our documentation. How to Contribute We welcome contributions in various forms: Writing Documentation Pages : This is our primary need. See \"Style Guide\" below for formatting guidelines. Fixing Typos and Errors : Even small corrections make a big difference. Improving Examples : Clear, concise examples are invaluable. Suggesting New Topics : Let us know what you'd like to see covered. Reporting Issues : If you find something unclear or incorrect, please report it! Getting Started Fork the Repository : Go to https://github.com/arcathrax/lemonjuce and click the \"Fork\" button. Clone Your Fork : Clone your forked repository to your local machine: git clone git@github.com:<your_username>/lemonjuce.git cd lemonjuce Create a Branch : Create a new branch for your changes. This keeps your work isolated and makes it easier to review. Use descriptive names! git checkout -b my-new-feature-or-fix Make Your Changes : Edit the Markdown files in the docs/ directory. (See \"Style Guide\" below). Commit Your Changes : Commit your changes with clear and concise commit messages. git add . git commit -m \"Fix: Corrected typo in LookAndFeel documentation\" # or git commit -m \"Feat: Documentation for CustomLookAndFeel class\" Push to Your Fork : Push your branch to your forked repository on GitHub. git push origin my-new-feature-or-fix Create a Pull Request : Go to your forked repository on GitHub and click the \"Create Pull Request\" button. Provide a detailed description of your changes, explaining why they are valuable. Style Guide To ensure consistency and readability, please follow these guidelines: Markdown Formatting : Use standard Markdown syntax. Headings : Use clear and descriptive headings (e.g., # Creating a Custom LookAndFeel , ## Implementation ). Code Blocks : Use fenced code blocks with the appropriate language identifier (e.g., ```cpp for C++ code). Images : Images should be hosted on GitHub or linked from external sources. Use descriptive alt text for accessibility. Links : Link to relevant JUCE documentation and other resources whenever possible. Use meaningful link text. Tone : Write in a clear, concise, and friendly tone. Assume the reader has some basic JUCE knowledge but may be struggling with specific concepts. Explain the \"why\" as much as the \"how.\" Examples : Provide practical examples that illustrate the concepts being explained. Keep examples short and focused. Consistency : Follow the existing style of lemonjuce documentation. Look at other pages for inspiration. Commit Message Conventions We follow these conventions to keep our commit history clean and understandable: Prefix : Use a prefix to indicate the type of change (e.g., feat , fix , refactor , style ). Scope : Specify the area of the project affected by the change (e.g., LookAndFeel , Graphics ). Description : Briefly describe the change in imperative mood (e.g., \"Corrected typo\", \"Add documentation\"). Examples: fix(creating_a_custom_look_and_feel.md): Corrected typo in drawRotarySlider function feat(creating_a_custom_look_and_feel.md): Create file feat(installation.md): Wrote \"Creating an Application\" section feat(contributing.md): Created file and wrote initial sections Contact For questions or discussions, please open an issue on GitHub. We look forward to your contributions!","title":"Contributing page"},{"location":"information/contributing/#contributing","text":"Welcome! Our goal is to provide clear, practical, and a self-contained documentation for JUCE development. Your contributions are vital to making that happen.","title":"Contributing"},{"location":"information/contributing/#why-contribute","text":"lemonjuce aims to bridge the gap between the powerful capabilities of JUCE and the sometimes-opaque nature of its documentation. By contributing, you'll: Improve your own understanding : Explaining concepts helps solidify them in your mind. Help others : Share your knowledge and make JUCE development more accessible to everyone. Shape lemonjuce : Help us define the scope and quality of our documentation.","title":"Why Contribute?"},{"location":"information/contributing/#how-to-contribute","text":"We welcome contributions in various forms: Writing Documentation Pages : This is our primary need. See \"Style Guide\" below for formatting guidelines. Fixing Typos and Errors : Even small corrections make a big difference. Improving Examples : Clear, concise examples are invaluable. Suggesting New Topics : Let us know what you'd like to see covered. Reporting Issues : If you find something unclear or incorrect, please report it!","title":"How to Contribute"},{"location":"information/contributing/#getting-started","text":"Fork the Repository : Go to https://github.com/arcathrax/lemonjuce and click the \"Fork\" button. Clone Your Fork : Clone your forked repository to your local machine: git clone git@github.com:<your_username>/lemonjuce.git cd lemonjuce Create a Branch : Create a new branch for your changes. This keeps your work isolated and makes it easier to review. Use descriptive names! git checkout -b my-new-feature-or-fix Make Your Changes : Edit the Markdown files in the docs/ directory. (See \"Style Guide\" below). Commit Your Changes : Commit your changes with clear and concise commit messages. git add . git commit -m \"Fix: Corrected typo in LookAndFeel documentation\" # or git commit -m \"Feat: Documentation for CustomLookAndFeel class\" Push to Your Fork : Push your branch to your forked repository on GitHub. git push origin my-new-feature-or-fix Create a Pull Request : Go to your forked repository on GitHub and click the \"Create Pull Request\" button. Provide a detailed description of your changes, explaining why they are valuable.","title":"Getting Started"},{"location":"information/contributing/#style-guide","text":"To ensure consistency and readability, please follow these guidelines: Markdown Formatting : Use standard Markdown syntax. Headings : Use clear and descriptive headings (e.g., # Creating a Custom LookAndFeel , ## Implementation ). Code Blocks : Use fenced code blocks with the appropriate language identifier (e.g., ```cpp for C++ code). Images : Images should be hosted on GitHub or linked from external sources. Use descriptive alt text for accessibility. Links : Link to relevant JUCE documentation and other resources whenever possible. Use meaningful link text. Tone : Write in a clear, concise, and friendly tone. Assume the reader has some basic JUCE knowledge but may be struggling with specific concepts. Explain the \"why\" as much as the \"how.\" Examples : Provide practical examples that illustrate the concepts being explained. Keep examples short and focused. Consistency : Follow the existing style of lemonjuce documentation. Look at other pages for inspiration.","title":"Style Guide"},{"location":"information/contributing/#commit-message-conventions","text":"We follow these conventions to keep our commit history clean and understandable: Prefix : Use a prefix to indicate the type of change (e.g., feat , fix , refactor , style ). Scope : Specify the area of the project affected by the change (e.g., LookAndFeel , Graphics ). Description : Briefly describe the change in imperative mood (e.g., \"Corrected typo\", \"Add documentation\"). Examples: fix(creating_a_custom_look_and_feel.md): Corrected typo in drawRotarySlider function feat(creating_a_custom_look_and_feel.md): Create file feat(installation.md): Wrote \"Creating an Application\" section feat(contributing.md): Created file and wrote initial sections","title":"Commit Message Conventions"},{"location":"information/contributing/#contact","text":"For questions or discussions, please open an issue on GitHub. We look forward to your contributions!","title":"Contact"},{"location":"information/other_resources/","text":"Resources This is a list of other resources besides this documentation, that you can use to learn the JUCE framework. DSP Musicdsp.org - A collection of algorithms, thoughts and snippets, gathered for the music dsp community. Matkat Music YouTube Channel - Long and useful tutorials for the JUCE framework. Akash Murthy YouTube Channel - Videos about various dsp topics.","title":"Other resources"},{"location":"information/other_resources/#resources","text":"This is a list of other resources besides this documentation, that you can use to learn the JUCE framework. DSP Musicdsp.org - A collection of algorithms, thoughts and snippets, gathered for the music dsp community. Matkat Music YouTube Channel - Long and useful tutorials for the JUCE framework. Akash Murthy YouTube Channel - Videos about various dsp topics.","title":"Resources"},{"location":"parameter_handling/implementing_an_apvts/","text":"Implementing an APVTS What's an APVTS? An APVTS (AudioProcessorValueTreeState) is a core class in JUCE that provides a powerful and flexible way to manage parameters for audio plugins. It acts as a central repository for all the plugin\u2019s adjustable parameters (knobs, sliders, switches, etc.). Additionally it automatically keeps the GUI controls synchronized with the underlying parameter values. When you change a knob in the GUI, APVTS updates the corresponding parameter value, and vice versa. Implementation Adding a APVTS to your plugin Define a function, that will create the parameters, used in the audio plugin. Write this in the private section of your AudioProcessor. file : PluginProcessor.h private: juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout(); Next, we need to implement the just defined function. Write this at the bottom of the file . Note : You need to change the classname from AudioProcessor to your AudioProcessor name. file : PluginProcessor.cpp juce::AudioProcessorValueTreeState::ParameterLayout AudioProcessor::createParameterLayout() { // defining a ParameterLayout juce::AudioProcessorValueTreeState::ParameterLayout layout; // create a ParameterFloat auto parameter = std::make_unique<juce::AudioParameterFloat> ( juce::ParameterID { \"param\", // identifier 1 // versionHint }, \"param\", // parameterName juce::NormalisableRange<float> ( 0.0f, // rangeStart 1.0f, // rangeEnd 0.000001f, // intervalValue 1.f // skewFactor ), 0.0f // defaultValue ); // add the parameter to the layout layout.add ( std::move(parameter) ); return layout; } Define the APVTS on the bottom of the public section of your PluginProcessor: file : PluginProcessor.h public: juce::AudioProcessorValueTreeState apvts{ *this, nullptr, \"Parameters\", createParameterLayout() } After those steps, you now should have a working APVTS in your project. Linking a slider to a parameter in the APVTS If everything works correctly, the APVTS should now be able to attach the parameters to a slider via a helper class. This can be done like the following. First make sure, that you have a slider to use. Here we will create a own test slider. We will define this above the JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) but below the APVTSTestingAudioProcessor& audioProcessor; . We also define the slider in the private seciton of our class. file : PluginEditor.h private: AudioProcessor& audioProcessor; // Rename AudioProcessor with your AudioProcessor name juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) }; Next, we add the slider to the GUI. Here we will need to add several things in several functions. In the constructor, add and make the slider visible: file : PluginEditor.cpp AudioProcessorEditor::AudioProcessorEditor (AudioProcessor& p) // Rename AudioProcessorEditor with your AudioProcessorEditor name : AudioProcessorEditor (&p), audioProcessor (p) { setSize (400, 300); addAndMakeVisible(slider); } change the resized funcion to this: file : PluginEditor.h void APVTSTestingAudioProcessorEditor::resized() { slider.setBounds(getBounds()); } If we now run the program, it should display a slider: After that, we need to attach the parameter to the slider. We can do this via the juce::AudioProcessorValueTreeState::SliderAttachment helper class. We need to initialize the SliderAttachment and give it the apvts from the AudioProcessor . Next, we tell the SliderAttachment, what parameter we want to attach to. In this case, this will be the \"param\" . And lastly, we need to tell the SliderAttachment, what slider to attach the parameter to. In this case, the slider's name is just slider . The private section of the header should now look as following: file : PluginEditor.h private: APVTSTestingAudioProcessor& audioProcessor; juce::Slider slider; juce::AudioProcessorValueTreeState::SliderAttachment sliderAttachment{audioProcessor.apvts, \"param\", slider}; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) If you done everything correctly, the SliderAttachment should now work and the slider now will go from 0 to 1. If you change the slider, the parameter automatically gets changed too.","title":"Implementing an APVTS"},{"location":"parameter_handling/implementing_an_apvts/#implementing-an-apvts","text":"","title":"Implementing an APVTS"},{"location":"parameter_handling/implementing_an_apvts/#whats-an-apvts","text":"An APVTS (AudioProcessorValueTreeState) is a core class in JUCE that provides a powerful and flexible way to manage parameters for audio plugins. It acts as a central repository for all the plugin\u2019s adjustable parameters (knobs, sliders, switches, etc.). Additionally it automatically keeps the GUI controls synchronized with the underlying parameter values. When you change a knob in the GUI, APVTS updates the corresponding parameter value, and vice versa.","title":"What's an APVTS?"},{"location":"parameter_handling/implementing_an_apvts/#implementation","text":"","title":"Implementation"},{"location":"parameter_handling/implementing_an_apvts/#adding-a-apvts-to-your-plugin","text":"Define a function, that will create the parameters, used in the audio plugin. Write this in the private section of your AudioProcessor. file : PluginProcessor.h private: juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout(); Next, we need to implement the just defined function. Write this at the bottom of the file . Note : You need to change the classname from AudioProcessor to your AudioProcessor name. file : PluginProcessor.cpp juce::AudioProcessorValueTreeState::ParameterLayout AudioProcessor::createParameterLayout() { // defining a ParameterLayout juce::AudioProcessorValueTreeState::ParameterLayout layout; // create a ParameterFloat auto parameter = std::make_unique<juce::AudioParameterFloat> ( juce::ParameterID { \"param\", // identifier 1 // versionHint }, \"param\", // parameterName juce::NormalisableRange<float> ( 0.0f, // rangeStart 1.0f, // rangeEnd 0.000001f, // intervalValue 1.f // skewFactor ), 0.0f // defaultValue ); // add the parameter to the layout layout.add ( std::move(parameter) ); return layout; } Define the APVTS on the bottom of the public section of your PluginProcessor: file : PluginProcessor.h public: juce::AudioProcessorValueTreeState apvts{ *this, nullptr, \"Parameters\", createParameterLayout() } After those steps, you now should have a working APVTS in your project.","title":"Adding a APVTS to your plugin"},{"location":"parameter_handling/implementing_an_apvts/#linking-a-slider-to-a-parameter-in-the-apvts","text":"If everything works correctly, the APVTS should now be able to attach the parameters to a slider via a helper class. This can be done like the following. First make sure, that you have a slider to use. Here we will create a own test slider. We will define this above the JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) but below the APVTSTestingAudioProcessor& audioProcessor; . We also define the slider in the private seciton of our class. file : PluginEditor.h private: AudioProcessor& audioProcessor; // Rename AudioProcessor with your AudioProcessor name juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) }; Next, we add the slider to the GUI. Here we will need to add several things in several functions. In the constructor, add and make the slider visible: file : PluginEditor.cpp AudioProcessorEditor::AudioProcessorEditor (AudioProcessor& p) // Rename AudioProcessorEditor with your AudioProcessorEditor name : AudioProcessorEditor (&p), audioProcessor (p) { setSize (400, 300); addAndMakeVisible(slider); } change the resized funcion to this: file : PluginEditor.h void APVTSTestingAudioProcessorEditor::resized() { slider.setBounds(getBounds()); } If we now run the program, it should display a slider: After that, we need to attach the parameter to the slider. We can do this via the juce::AudioProcessorValueTreeState::SliderAttachment helper class. We need to initialize the SliderAttachment and give it the apvts from the AudioProcessor . Next, we tell the SliderAttachment, what parameter we want to attach to. In this case, this will be the \"param\" . And lastly, we need to tell the SliderAttachment, what slider to attach the parameter to. In this case, the slider's name is just slider . The private section of the header should now look as following: file : PluginEditor.h private: APVTSTestingAudioProcessor& audioProcessor; juce::Slider slider; juce::AudioProcessorValueTreeState::SliderAttachment sliderAttachment{audioProcessor.apvts, \"param\", slider}; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) If you done everything correctly, the SliderAttachment should now work and the slider now will go from 0 to 1. If you change the slider, the parameter automatically gets changed too.","title":"Linking a slider to a parameter in the APVTS"}]}