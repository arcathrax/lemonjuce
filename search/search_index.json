{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started Welcome to lemonjuce. This is my personal collection of notes and examples related to using JUCE. I created it as a way to keep track of useful information \u2013 things I often find myself needing but that are scattered across forums and other resources. It's meant to be a quick reference for me, arcathrax , so I don't have to hunt down the same solutions every time! One thing I\u2019ve found frustrating with the official JUCE tutorials is that they sometimes rely on custom classes defined in previous tutorials. It can be a bit of a surprise when you're trying to follow along and suddenly get errors because you haven't created those supporting classes yet! This documentation aims to provide more complete, self-contained examples whenever possible, or at least clearly indicate any dependencies on earlier tutorial content.","title":"Home"},{"location":"#getting-started","text":"Welcome to lemonjuce. This is my personal collection of notes and examples related to using JUCE. I created it as a way to keep track of useful information \u2013 things I often find myself needing but that are scattered across forums and other resources. It's meant to be a quick reference for me, arcathrax , so I don't have to hunt down the same solutions every time! One thing I\u2019ve found frustrating with the official JUCE tutorials is that they sometimes rely on custom classes defined in previous tutorials. It can be a bit of a surprise when you're trying to follow along and suddenly get errors because you haven't created those supporting classes yet! This documentation aims to provide more complete, self-contained examples whenever possible, or at least clearly indicate any dependencies on earlier tutorial content.","title":"Getting started"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/","text":"Implementing an AudioProcessorValueTreeState What's an APVTS? An APVTS (AudioProcessorValueTreeState) is a core class in JUCE that provides a powerful and flexible way to manage parameters for audio plugins. It acts as a central repository for all the plugin\u2019s adjustable parameters (knobs, sliders, switches, etc.). Additionally it automatically keeps the GUI controls synchronized with the underlying parameter values. When you change a knob in the GUI, APVTS updates the corresponding parameter value, and vice versa. Implementation Adding a APVTS to your plugin Define a function, that will create the parameters, used in the audio plugin. Write this in the private section of your AudioProcessor. file : PluginProcessor.h private: juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout(); Next, we need to implement the just defined function. Write this at the bottom of the file . Note : You need to change the classname from AudioProcessor to your AudioProcessor name. file : PluginProcessor.cpp juce::AudioProcessorValueTreeState::ParameterLayout AudioProcessor::createParameterLayout() { // defining a ParameterLayout juce::AudioProcessorValueTreeState::ParameterLayout layout; // create a ParameterFloat auto parameter = std::make_unique<juce::AudioParameterFloat> ( juce::ParameterID { \"param\", // identifier 1 // versionHint }, \"param\", // parameterName juce::NormalisableRange<float> ( 0.0f, // rangeStart 1.0f, // rangeEnd 0.000001f, // intervalValue 1.f // skewFactor ), 0.0f // defaultValue ); // add the parameter to the layout layout.add ( std::move(parameter) ); return layout; } Define the APVTS on the bottom of the public section of your PluginProcessor: file : PluginProcessor.h public: juce::AudioProcessorValueTreeState apvts{ *this, nullptr, \"Parameters\", createParameterLayout() } After those steps, you now should have a working APVTS in your project. Linking a slider to a parameter in the APVTS If everything works correctly, the APVTS should now be able to attach the parameters to a slider via a helper class. This can be done like the following. First make sure, that you have a slider to use. Here we will create a own test slider. We will define this above the JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) but below the APVTSTestingAudioProcessor& audioProcessor; . We also define the slider in the private seciton of our class. file : PluginEditor.h private: AudioProcessor& audioProcessor; // Rename AudioProcessor with your AudioProcessor name juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) }; Next, we add the slider to the GUI. Here we will need to add several things in several funcitons. In the constructor, add and make the slider visible: file : PluginEditor.h AudioProcessorEditor::AudioProcessorEditor (AudioProcessor& p) // Rename AudioProcessorEditor with your AudioProcessorEditor name : AudioProcessorEditor (&p), audioProcessor (p) { setSize (400, 300); addAndMakeVisible(slider); } change the resized funcion to this: file : PluginEditor.h void APVTSTestingAudioProcessorEditor::resized() { slider.setBounds(getBounds()); } If we now run the program, it should display a slider: After that, we need to attach the parameter to the slider. We can do this via the juce::AudioProcessorValueTreeState::SliderAttachment helper class. We need to initialize the SliderAttachment and give it the apvts from the AudioProcessor . Next, we tell the SliderAttachment, what parameter we want to attach to. In this case, this will be the \"param\" . And lastly, we need to tell the SliderAttachment, what slider to attach the parameter to. In this case, the slider's name is just slider . The private section of the header should now look as following: file : PluginEditor.h private: APVTSTestingAudioProcessor& audioProcessor; juce::Slider slider; juce::AudioProcessorValueTreeState::SliderAttachment sliderAttachment{audioProcessor.apvts, \"param\", slider}; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) If you done everything correctly, the SliderAttachment should now work and the slider now will go from 0 to 1. If you change the slider, the parameter automatically gets changed too.","title":"Implementing an AudioProcessorValueTreeState"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/#implementing-an-audioprocessorvaluetreestate","text":"","title":"Implementing an AudioProcessorValueTreeState"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/#whats-an-apvts","text":"An APVTS (AudioProcessorValueTreeState) is a core class in JUCE that provides a powerful and flexible way to manage parameters for audio plugins. It acts as a central repository for all the plugin\u2019s adjustable parameters (knobs, sliders, switches, etc.). Additionally it automatically keeps the GUI controls synchronized with the underlying parameter values. When you change a knob in the GUI, APVTS updates the corresponding parameter value, and vice versa.","title":"What's an APVTS?"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/#implementation","text":"","title":"Implementation"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/#adding-a-apvts-to-your-plugin","text":"Define a function, that will create the parameters, used in the audio plugin. Write this in the private section of your AudioProcessor. file : PluginProcessor.h private: juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout(); Next, we need to implement the just defined function. Write this at the bottom of the file . Note : You need to change the classname from AudioProcessor to your AudioProcessor name. file : PluginProcessor.cpp juce::AudioProcessorValueTreeState::ParameterLayout AudioProcessor::createParameterLayout() { // defining a ParameterLayout juce::AudioProcessorValueTreeState::ParameterLayout layout; // create a ParameterFloat auto parameter = std::make_unique<juce::AudioParameterFloat> ( juce::ParameterID { \"param\", // identifier 1 // versionHint }, \"param\", // parameterName juce::NormalisableRange<float> ( 0.0f, // rangeStart 1.0f, // rangeEnd 0.000001f, // intervalValue 1.f // skewFactor ), 0.0f // defaultValue ); // add the parameter to the layout layout.add ( std::move(parameter) ); return layout; } Define the APVTS on the bottom of the public section of your PluginProcessor: file : PluginProcessor.h public: juce::AudioProcessorValueTreeState apvts{ *this, nullptr, \"Parameters\", createParameterLayout() } After those steps, you now should have a working APVTS in your project.","title":"Adding a APVTS to your plugin"},{"location":"advanced/implementing_an_audioprocessorvaluetreestate/implementing_an_audioprocessorvaluetreestate/#linking-a-slider-to-a-parameter-in-the-apvts","text":"If everything works correctly, the APVTS should now be able to attach the parameters to a slider via a helper class. This can be done like the following. First make sure, that you have a slider to use. Here we will create a own test slider. We will define this above the JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) but below the APVTSTestingAudioProcessor& audioProcessor; . We also define the slider in the private seciton of our class. file : PluginEditor.h private: AudioProcessor& audioProcessor; // Rename AudioProcessor with your AudioProcessor name juce::Slider slider; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) }; Next, we add the slider to the GUI. Here we will need to add several things in several funcitons. In the constructor, add and make the slider visible: file : PluginEditor.h AudioProcessorEditor::AudioProcessorEditor (AudioProcessor& p) // Rename AudioProcessorEditor with your AudioProcessorEditor name : AudioProcessorEditor (&p), audioProcessor (p) { setSize (400, 300); addAndMakeVisible(slider); } change the resized funcion to this: file : PluginEditor.h void APVTSTestingAudioProcessorEditor::resized() { slider.setBounds(getBounds()); } If we now run the program, it should display a slider: After that, we need to attach the parameter to the slider. We can do this via the juce::AudioProcessorValueTreeState::SliderAttachment helper class. We need to initialize the SliderAttachment and give it the apvts from the AudioProcessor . Next, we tell the SliderAttachment, what parameter we want to attach to. In this case, this will be the \"param\" . And lastly, we need to tell the SliderAttachment, what slider to attach the parameter to. In this case, the slider's name is just slider . The private section of the header should now look as following: file : PluginEditor.h private: APVTSTestingAudioProcessor& audioProcessor; juce::Slider slider; juce::AudioProcessorValueTreeState::SliderAttachment sliderAttachment{audioProcessor.apvts, \"param\", slider}; JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (APVTSTestingAudioProcessorEditor) If you done everything correctly, the SliderAttachment should now work and the slider now will go from 0 to 1. If you change the slider, the parameter automatically gets changed too.","title":"Linking a slider to a parameter in the APVTS"},{"location":"getting_started/creating_an_audio_plugin/creating_an_audio_plugin/","text":"Creating an audio plugin Create the project To create an audio plug-in with JUCE, open \"Projucer\" and select \"Plug-In>Basic\". See Creating an Application if you don't know how to do that. In this tutorial we're going to name this plugin SimpleAudioPlugin . In this tutorial, we are going to create a VST3 plug-in, so make sure, that the VST3 setting is ticked in the Plugin Formats field in the project configuration settings: Project configuration In the project configuration you can change and tweak much more settings. Here you can change for example the project version, the plug-in type (generator or effect), change the plug-in category (ex. distortion or delay) and much more. However we dont need to change anything besides the \"plugin format\". Next click the \" Save and Open in IDE \"-button and build it . Setup debugging environment (optional) When creating a audio plugin, accessing it fast and reliable is sometimes a hassle since DAW's sometimes have issues finding updated plugins and are very cpu intensive. Thankfully, JUCE has a simple environment to debug your application called \"AudioPluginHost\". This application serves as a host for your plug-ing and you can use it just like in a DAW. The \"AudioPluginHost\" can be started very quickly and is very easy to use, which makes it perfect for debugging. To use the \"AudioPluginHost\", you first need to build it, since it doesn't come pre-compiled, like \"Projucer\" does. Go to JUCE/extras/AudioPluginHost and open the .jucer file. Click the \"Save and Open in IDE\"-button and build the project. This will create a binary file, located in one of the following folders: OS Location macOS JUCE/extras/AudioPluginHost/Builds/MacOSX/build/... Windows JUCE\\extras\\AudioPluginHost\\Builds\\VisualStudio2022\\... Note: The application is somewhere in the subfolders of the build folder. You can can change the location of the \"AudioPluginHost\" to your likings. If you run the \"AudioPluginHost\", you should see the graphical node editor that looks like this: You can search for plugins by going to Options>Edit the List of Available Plug-ins... . Click Options...>Scan for new or updated VST3 plug-ins to see the folders, that should be scanned by the \"AudioPluginHost\". Here you can select the folders, that are going to be scanned for new VST3 plug-ins. Here you can add or remove custom directories: Once the scan is complete go back to the node editor and right click, then select your plug-in from the context menu (it will be under a company called \"yourcompany\" by default. You can edit this in the \"Projucer\"). Connect the nodes up such that the Audio is routed to and from the \"SimpleAudioPlugin\": If you now double click onto the plugin node, you open the GUI of the plugin. The default does nothing but show Hello world . Automatically run AudioPluginHost If you want to run \"AudioPluginHost\" automatically when building your project, you can do that via the IDE. In Xcode click Product>Scheme>Edit Scheme... , then under Run>Info>Executable>Other... search and select the \"AudioPluginHost\". In Visual Studio go to SimpleAudioPlugin_VST3 Debug Properties>Debugging>Command and change it to the path to the \"AudioPluginHost\".","title":"Creating an audio plugin"},{"location":"getting_started/creating_an_audio_plugin/creating_an_audio_plugin/#creating-an-audio-plugin","text":"","title":"Creating an audio plugin"},{"location":"getting_started/creating_an_audio_plugin/creating_an_audio_plugin/#create-the-project","text":"To create an audio plug-in with JUCE, open \"Projucer\" and select \"Plug-In>Basic\". See Creating an Application if you don't know how to do that. In this tutorial we're going to name this plugin SimpleAudioPlugin . In this tutorial, we are going to create a VST3 plug-in, so make sure, that the VST3 setting is ticked in the Plugin Formats field in the project configuration settings: Project configuration In the project configuration you can change and tweak much more settings. Here you can change for example the project version, the plug-in type (generator or effect), change the plug-in category (ex. distortion or delay) and much more. However we dont need to change anything besides the \"plugin format\". Next click the \" Save and Open in IDE \"-button and build it .","title":"Create the project"},{"location":"getting_started/creating_an_audio_plugin/creating_an_audio_plugin/#setup-debugging-environment-optional","text":"When creating a audio plugin, accessing it fast and reliable is sometimes a hassle since DAW's sometimes have issues finding updated plugins and are very cpu intensive. Thankfully, JUCE has a simple environment to debug your application called \"AudioPluginHost\". This application serves as a host for your plug-ing and you can use it just like in a DAW. The \"AudioPluginHost\" can be started very quickly and is very easy to use, which makes it perfect for debugging. To use the \"AudioPluginHost\", you first need to build it, since it doesn't come pre-compiled, like \"Projucer\" does. Go to JUCE/extras/AudioPluginHost and open the .jucer file. Click the \"Save and Open in IDE\"-button and build the project. This will create a binary file, located in one of the following folders: OS Location macOS JUCE/extras/AudioPluginHost/Builds/MacOSX/build/... Windows JUCE\\extras\\AudioPluginHost\\Builds\\VisualStudio2022\\... Note: The application is somewhere in the subfolders of the build folder. You can can change the location of the \"AudioPluginHost\" to your likings. If you run the \"AudioPluginHost\", you should see the graphical node editor that looks like this: You can search for plugins by going to Options>Edit the List of Available Plug-ins... . Click Options...>Scan for new or updated VST3 plug-ins to see the folders, that should be scanned by the \"AudioPluginHost\". Here you can select the folders, that are going to be scanned for new VST3 plug-ins. Here you can add or remove custom directories: Once the scan is complete go back to the node editor and right click, then select your plug-in from the context menu (it will be under a company called \"yourcompany\" by default. You can edit this in the \"Projucer\"). Connect the nodes up such that the Audio is routed to and from the \"SimpleAudioPlugin\": If you now double click onto the plugin node, you open the GUI of the plugin. The default does nothing but show Hello world .","title":"Setup debugging environment (optional)"},{"location":"getting_started/creating_an_audio_plugin/creating_an_audio_plugin/#automatically-run-audiopluginhost","text":"If you want to run \"AudioPluginHost\" automatically when building your project, you can do that via the IDE. In Xcode click Product>Scheme>Edit Scheme... , then under Run>Info>Executable>Other... search and select the \"AudioPluginHost\". In Visual Studio go to SimpleAudioPlugin_VST3 Debug Properties>Debugging>Command and change it to the path to the \"AudioPluginHost\".","title":"Automatically run AudioPluginHost"},{"location":"getting_started/installation/installation/","text":"Installation Installing JUCE Before creating your first JUCE application, make sure that your local machine has either Visual Studio or Xcode installed. In addition, you need to install the C++ toolchain for the according opperating system: Visual Studio : During installation, ensure that you select the \"Desktop development with C++\" workload. Xcode : After installation, ensure that you the right components: File>Settings>Components>macOS XX.X You now may download JUCE from here . Unpack the JUCE folder and place it to some location on your computer. Your user home folder is a convenient place. Go into the JUCE folder you just moved. Launch the \"Projucer\", which is located in there. Note: You need to setup the path to JUCE and the JUCE modules. This should look something like this: Creating an Application If you are launching \"Projucer\" for the first time, you are presented with the new project window. You also can access this window via File>New Project . Projucer - New Project Window Select your project type On the left-hand side of \"Projucer\", you can select a project type. This will add all the dependencies to create the programm selected and create code, to make the application run. You can select from the following types: Project type Description Application > Blank Creates a blank JUCE application Application > GUI Creates a blank JUCE application with a application window. Application > Audio Creates a application like \"Application > GUI\", but with all the setup code for audio in- and outputs. Application > Console Creates a command-line application without a GUI Application > Animated Creates a JUCE GUI application which is optimized for animations. Application > OpenGL Creates a JUCE GUI application with support for openGL drawing, like 3D model import and GLSL shaders. Plug-In > Basic Creates a basic audio plug-in. This plugin can be exported in the VST, Audio Unit and AAX formats. Plug-In > ARA Creates a plugin with ARA (Audio Random Access) support. Library > Static Library Creates a library that will be compiled into the final executable. Library > Dynamic Library Creates a library that are linked at runtime. Alternatively, you may start with a example project. You can open those by clicking the \"Open Example\" tab on the left-hand side of \"Projucer\". Create the Project After you selected the project type, you can fill out some additional project settings on the right-hand side: - Project Name : Give your application a custom Name - Modules : Here you can add and remove modules, that you are going to use in your project. - Exporters : Here you select which IDEs you want to use to build and debug your app. The Projucer currently has exporters for the following IDEs: OS build systems macOS Xcode Windows Visual Studio Linux Makefile iOS Xcode Android Android Studio Note: If you use Visual Studio create a audio plugin and don't want to manually copy the plugin after every build, I suggest you to enable the \"Plugin Copy Step\": Export the project and open in IDE After you created your project and set everything up, you can launch your IDE withing Projucer: Open existing projects To open existing Projucer project's, you can either double-click the .jucer file in your project or click on \"File>Open...\" in Projucer.","title":"Installation"},{"location":"getting_started/installation/installation/#installation","text":"","title":"Installation"},{"location":"getting_started/installation/installation/#installing-juce","text":"Before creating your first JUCE application, make sure that your local machine has either Visual Studio or Xcode installed. In addition, you need to install the C++ toolchain for the according opperating system: Visual Studio : During installation, ensure that you select the \"Desktop development with C++\" workload. Xcode : After installation, ensure that you the right components: File>Settings>Components>macOS XX.X You now may download JUCE from here . Unpack the JUCE folder and place it to some location on your computer. Your user home folder is a convenient place. Go into the JUCE folder you just moved. Launch the \"Projucer\", which is located in there. Note: You need to setup the path to JUCE and the JUCE modules. This should look something like this:","title":"Installing JUCE"},{"location":"getting_started/installation/installation/#creating-an-application","text":"If you are launching \"Projucer\" for the first time, you are presented with the new project window. You also can access this window via File>New Project . Projucer - New Project Window","title":"Creating an Application"},{"location":"getting_started/installation/installation/#select-your-project-type","text":"On the left-hand side of \"Projucer\", you can select a project type. This will add all the dependencies to create the programm selected and create code, to make the application run. You can select from the following types: Project type Description Application > Blank Creates a blank JUCE application Application > GUI Creates a blank JUCE application with a application window. Application > Audio Creates a application like \"Application > GUI\", but with all the setup code for audio in- and outputs. Application > Console Creates a command-line application without a GUI Application > Animated Creates a JUCE GUI application which is optimized for animations. Application > OpenGL Creates a JUCE GUI application with support for openGL drawing, like 3D model import and GLSL shaders. Plug-In > Basic Creates a basic audio plug-in. This plugin can be exported in the VST, Audio Unit and AAX formats. Plug-In > ARA Creates a plugin with ARA (Audio Random Access) support. Library > Static Library Creates a library that will be compiled into the final executable. Library > Dynamic Library Creates a library that are linked at runtime. Alternatively, you may start with a example project. You can open those by clicking the \"Open Example\" tab on the left-hand side of \"Projucer\".","title":"Select your project type"},{"location":"getting_started/installation/installation/#create-the-project","text":"After you selected the project type, you can fill out some additional project settings on the right-hand side: - Project Name : Give your application a custom Name - Modules : Here you can add and remove modules, that you are going to use in your project. - Exporters : Here you select which IDEs you want to use to build and debug your app. The Projucer currently has exporters for the following IDEs: OS build systems macOS Xcode Windows Visual Studio Linux Makefile iOS Xcode Android Android Studio Note: If you use Visual Studio create a audio plugin and don't want to manually copy the plugin after every build, I suggest you to enable the \"Plugin Copy Step\":","title":"Create the Project"},{"location":"getting_started/installation/installation/#export-the-project-and-open-in-ide","text":"After you created your project and set everything up, you can launch your IDE withing Projucer:","title":"Export the project and open in IDE"},{"location":"getting_started/installation/installation/#open-existing-projects","text":"To open existing Projucer project's, you can either double-click the .jucer file in your project or click on \"File>Open...\" in Projucer.","title":"Open existing projects"},{"location":"getting_started/plugin_architecture/plugin_architecture/","text":"Plugin architecture An audio plug-in, made with JUCE consists of several folders and files. However, the main stuff will happen within two files: The PluginProcessor and the PluginEditor . The \"PluginProcessor\" will process the audio while the \"PluginEditor\" will handle the GUI. We will take a closer look later in this file. General structure Every audio plug-in, made with JUCE will have the following folders: YourAudioPlugin |-Source |-PluginEditor.cpp |-PluginEditor.h |-PluginProcessor.cpp |-PluginEditor.h |-Builds |-Juce Library Code The Source -folder holds the source code of the JUCE application. The GUI is defined here, aswell as the audio processing stuff. The Builds -folder holds the export targets generated by the \"Projucer\". The generated binaries will also be exported to some subfolder here. Lastly, the folder JuceLibraryCode holds autogenerated files, that are essential to include the JUCE modules. Those will be deleted and completely re-written whenever the Projucer saves your project. You really should't change anything here since it just will get deleted. Since most of the work is done in the Source -folder, we should take a closer look to the files inside. PluginProcessor In a JUCE audio plug-in, the PluginProcessor is the core engine that handles all audio processing, parameter management and plugin state. It is where your plugin actually does the sound-related work. You're going to write a lot of code in some functions and in some, you maybe don't need to write that much code. Here are the most used classes within \"PluginProcessor\": prepareToPlay() : Initialization happen here. This will get called right before the audio is being processed. processBlock() : Here you will manipulate the audio in real time. releaseRessources() : When playback stops, you can use this as an opportunity to free up any spare memory, etc. getStateInformation() : This will load the state of the plug-in. setStateInformation() : This will save the state of the plug-in. createEditor() : This will create the window for the plug-in. Note: The \"state\" of the plugin is just in what state the parameters of the plugin are. PluginEditor In a JUCE audio plug-in, the \"PluginEditor\" is the graphical user interface (GUI) that allows users to interact with your plugin. It displays sliders, buttons, meters, and other controls, and connects them to the audio processing happening in the \"PluginProcessor\". Here, you will build your interface and decide how users will interact with your parameters. Sometimes there are just few sliders, sometimes it's a whole custom visual environment. Here are the classes within \"PluginEditor\": paint() : This is where you draw any custom graphics or backgrounds. resized() : Called when the editor changes size.","title":"Plugin architecture"},{"location":"getting_started/plugin_architecture/plugin_architecture/#plugin-architecture","text":"An audio plug-in, made with JUCE consists of several folders and files. However, the main stuff will happen within two files: The PluginProcessor and the PluginEditor . The \"PluginProcessor\" will process the audio while the \"PluginEditor\" will handle the GUI. We will take a closer look later in this file.","title":"Plugin architecture"},{"location":"getting_started/plugin_architecture/plugin_architecture/#general-structure","text":"Every audio plug-in, made with JUCE will have the following folders: YourAudioPlugin |-Source |-PluginEditor.cpp |-PluginEditor.h |-PluginProcessor.cpp |-PluginEditor.h |-Builds |-Juce Library Code The Source -folder holds the source code of the JUCE application. The GUI is defined here, aswell as the audio processing stuff. The Builds -folder holds the export targets generated by the \"Projucer\". The generated binaries will also be exported to some subfolder here. Lastly, the folder JuceLibraryCode holds autogenerated files, that are essential to include the JUCE modules. Those will be deleted and completely re-written whenever the Projucer saves your project. You really should't change anything here since it just will get deleted. Since most of the work is done in the Source -folder, we should take a closer look to the files inside.","title":"General structure"},{"location":"getting_started/plugin_architecture/plugin_architecture/#pluginprocessor","text":"In a JUCE audio plug-in, the PluginProcessor is the core engine that handles all audio processing, parameter management and plugin state. It is where your plugin actually does the sound-related work. You're going to write a lot of code in some functions and in some, you maybe don't need to write that much code. Here are the most used classes within \"PluginProcessor\": prepareToPlay() : Initialization happen here. This will get called right before the audio is being processed. processBlock() : Here you will manipulate the audio in real time. releaseRessources() : When playback stops, you can use this as an opportunity to free up any spare memory, etc. getStateInformation() : This will load the state of the plug-in. setStateInformation() : This will save the state of the plug-in. createEditor() : This will create the window for the plug-in. Note: The \"state\" of the plugin is just in what state the parameters of the plugin are.","title":"PluginProcessor"},{"location":"getting_started/plugin_architecture/plugin_architecture/#plugineditor","text":"In a JUCE audio plug-in, the \"PluginEditor\" is the graphical user interface (GUI) that allows users to interact with your plugin. It displays sliders, buttons, meters, and other controls, and connects them to the audio processing happening in the \"PluginProcessor\". Here, you will build your interface and decide how users will interact with your parameters. Sometimes there are just few sliders, sometimes it's a whole custom visual environment. Here are the classes within \"PluginEditor\": paint() : This is where you draw any custom graphics or backgrounds. resized() : Called when the editor changes size.","title":"PluginEditor"},{"location":"getting_started/what_is_juce/what_is_juce/","text":"What is JUCE? JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plug-ins libraries. It is dual licensed under the GPLv3 and a commercial license. The aim of JUCE is to allow software to be written such that the same source code will compile and run identically on Windows, macOS and Linux platforms. It supports various development environments and compilers. Features JUCE provides a range of functions, covering user-interface elements, graphics, audio, XML and JSON parsing, networking, cryptography, multi-threading, an integrated interpreter that mimics ECMAScript's syntax and various other commonly used features. A notable feature of JUCE when compared to other similar frameworks, like Qt or GTK, is its large set of audio functionality; this is because JUCE was originally developed as a framework for Tracktion, an audio sequencer, before being split off into a standalone product. JUCE comes with wrapper classes for building audio and browser plugins. When building an audio plugin, multiple plugin formats can be selected for build targets. Those include VST & VST3, RTAS, AAX and Audio Units. Tools Projucer The \"Projucer\" is an IDE tool for creating and managing JUCE projects. When the files and settings for a JUCE project have been specified, the Projucer automatically generates a collection of 3rd-party project files to allow the project to be compiled natively on each target platform. It can currently generate Xcode projects, Visual Studio Projects, Linux Makefiles, Android Ant builds and CodeBlocks projects. AudioPluginHost The \"AudioPluginHost\" is a standalone application included with JUCE that allows users to load, test, and route audio plugins in a flexible environment. Designed primarly for plugin development and testing, it supports both VST and AU plugin formats and provides a real-time visual interface for managing plugin chains. With its built-in graph editor, users can freely connect audio and MIDI paths between loaded plugins, making it an essential tool for quickly verifying plugin behaviour outside of a DAW.","title":"What is JUCE?"},{"location":"getting_started/what_is_juce/what_is_juce/#what-is-juce","text":"JUCE is an open-source cross-platform C++ application framework, used for the development of desktop and mobile applications. JUCE is used in particular for its GUI and plug-ins libraries. It is dual licensed under the GPLv3 and a commercial license. The aim of JUCE is to allow software to be written such that the same source code will compile and run identically on Windows, macOS and Linux platforms. It supports various development environments and compilers.","title":"What is JUCE?"},{"location":"getting_started/what_is_juce/what_is_juce/#features","text":"JUCE provides a range of functions, covering user-interface elements, graphics, audio, XML and JSON parsing, networking, cryptography, multi-threading, an integrated interpreter that mimics ECMAScript's syntax and various other commonly used features. A notable feature of JUCE when compared to other similar frameworks, like Qt or GTK, is its large set of audio functionality; this is because JUCE was originally developed as a framework for Tracktion, an audio sequencer, before being split off into a standalone product. JUCE comes with wrapper classes for building audio and browser plugins. When building an audio plugin, multiple plugin formats can be selected for build targets. Those include VST & VST3, RTAS, AAX and Audio Units.","title":"Features"},{"location":"getting_started/what_is_juce/what_is_juce/#tools","text":"","title":"Tools"},{"location":"getting_started/what_is_juce/what_is_juce/#projucer","text":"The \"Projucer\" is an IDE tool for creating and managing JUCE projects. When the files and settings for a JUCE project have been specified, the Projucer automatically generates a collection of 3rd-party project files to allow the project to be compiled natively on each target platform. It can currently generate Xcode projects, Visual Studio Projects, Linux Makefiles, Android Ant builds and CodeBlocks projects.","title":"Projucer"},{"location":"getting_started/what_is_juce/what_is_juce/#audiopluginhost","text":"The \"AudioPluginHost\" is a standalone application included with JUCE that allows users to load, test, and route audio plugins in a flexible environment. Designed primarly for plugin development and testing, it supports both VST and AU plugin formats and provides a real-time visual interface for managing plugin chains. With its built-in graph editor, users can freely connect audio and MIDI paths between loaded plugins, making it an essential tool for quickly verifying plugin behaviour outside of a DAW.","title":"AudioPluginHost"}]}